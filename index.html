<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Modular Multi-Planet View</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; background: #000; }
  </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="uiPanel" style="
  position: absolute;
  top: 20px;
  left: 20px;
  background: rgba(20,20,30,0.9);
  color: white;
  padding: 10px 15px;
  border-radius: 10px;
  font-family: sans-serif;
  font-size: 14px;
  display: none;
  z-index: 10;
  min-width: 200px;
">
</div>
<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
resizeCanvas();
window.addEventListener("resize", resizeCanvas);

function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}

// Global view transforms
let zoom = 1;
let panX = 0, panY = 0;
let isDragging = false;
let lastMouseX = 0, lastMouseY = 0;
let list_resources = ['iron', 'copper', 'food', 'water', 'silicon', 'gold', 'crystal', 'structium'];
let resources_colors = {
  iron: "#99aaad",
  copper: "#f2a049",
  food: "#07ab2a",
  water: "#0048ff",
  silicon: "#cccccc",
  gold: "#ffd700",
  crystal: "#00ffff",
  structium: "#cc6600"
};

var planetTypes = ['desert', 'jungle', 'lava', 'ice', 'rocky'];

var planetColors = {
  desert: '#d2b48c',
  jungle: '#228b22',
  lava: '#ff4500',
  ice: '#add8e6',
  rocky: '#888888'
};

var resourceBias = {
  desert: ['iron', 'iron','silicon', 'silicon', 'silicon', 'gold', 'gold', 'food', 'structium', 'structium'],
  jungle: ['food','food','food','food','water','water', 'water', 'crystal', 'structium'],
  lava: ['iron', 'iron', 'iron', 'copper', 'gold', 'structium', 'structium'],
  ice: ['water', 'water', 'water', 'water', 'crystal', 'crystal', 'silicon', 'structium'],
  rocky: ['iron','iron', 'copper', 'copper', 'silicon', 'silicon', 'water', 'structium', 'structium']
};

let lastUIState = { type: null, ref: null };

canvas.addEventListener("wheel", (e) => {
  e.preventDefault();
  
  const mouseX = e.clientX;
  const mouseY = e.clientY;

  const worldX = (mouseX - panX) / zoom;
  const worldY = (mouseY - panY) / zoom;

  const zoomFactor = e.deltaY < 0 ? 1.1 : 1 / 1.1;
  zoom *= zoomFactor;

  // Adjust pan to keep zoom centered at mouse
  panX = mouseX - worldX * zoom;
  panY = mouseY - worldY * zoom;
});


canvas.addEventListener("mousedown", (e) => {
  isDragging = true;
  lastMouseX = e.clientX;
  lastMouseY = e.clientY;
});
canvas.addEventListener("mousemove", (e) => {
  if (isDragging) {
    let dx = e.clientX - lastMouseX;
    let dy = e.clientY - lastMouseY;
    panX += dx;
    panY += dy;
    lastMouseX = e.clientX;
    lastMouseY = e.clientY;
  }
});
canvas.addEventListener("mouseup", () => isDragging = false);
canvas.addEventListener("mouseleave", () => isDragging = false);

document.onkeydown=function(e){
  if(e.key === "Escape"){
    planets.forEach(p=>{
      p.selectedColonist=null;
    });
    selectedBase = null;
    selectedSpaceship = null;
    
  }
	if(e.key ==="c"){
		if(selectedSpaceship){
			panX = document.querySelector("body").clientWidth/2 - selectedSpaceship.x * zoom;
			panY = document.querySelector("body").clientHeight/2 - selectedSpaceship.y * zoom;
			return
		}
		for(let p of planets){
			if(p.selectedColonist){
				let pos = p.getSurfacePosition(p.selectedColonist.angle);
				panX = document.querySelector("body").clientWidth/2 - pos.x * zoom;
				panY = document.querySelector("body").clientHeight/2 - pos.y * zoom;
				return
			}
			if(selectedBase && p.buildings.find(b=>b==selectedBase)){
				let pos = p.getSurfacePosition(selectedBase.angle);
				panX = document.querySelector("body").clientWidth/2 - pos.x * zoom;
				panY = document.querySelector("body").clientHeight/2 - pos.y * zoom;
				return
			}
		}
	}
  if(e.key === "i"){
    //find an idle colonist
    planets.forEach(p=>{
      p.colonists.filter(x => x !== p.selectedColonist).forEach(c=>{
        if((c.state === "idle")){
          p.selectedColonist = c;
          return
        }
      });
      return
    });
    
  }
  if(e.key === "s"){
    //find an idle colonist
    selectedSpaceship = spaceships.find(s=>!s.moving);
    
  }
  if(e.key === "+"){
		const worldX = (document.querySelector("body").clientWidth/2 - panX) / zoom;
  	const worldY = (document.querySelector("body").clientHeight/2 - panY) / zoom;
		zoom*=1.1;
		panX = document.querySelector("body").clientWidth/2 - worldX * zoom;
  	panY = document.querySelector("body").clientHeight/2 - worldY * zoom;
	
	}
	if(e.key === "-"){
		const worldX = (document.querySelector("body").clientWidth/2 - panX) / zoom;
  	const worldY = (document.querySelector("body").clientHeight/2 - panY) / zoom;
		zoom/=1.1;
		panX = document.querySelector("body").clientWidth/2 - worldX * zoom;
  	panY = document.querySelector("body").clientHeight/2 - worldY * zoom;
	
	}
}

function lightenColor(hex, percent) {
  let num = parseInt(hex.replace('#', ''), 16),
      amt = Math.round(2.55 * percent),
      R = (num >> 16) + amt,
      G = (num >> 8 & 0x00FF) + amt,
      B = (num & 0x0000FF) + amt;
  return "#" + (
    0x1000000 +
    (R < 255 ? R<1?0:R : 255)*0x10000 +
    (G < 255 ? G<1?0:G : 255)*0x100 +
    (B < 255 ? B<1?0:B : 255)
  ).toString(16).slice(1);
}

function capitalize(text){
	return text.charAt(0).toUpperCase()+text.slice(1)
}

class Spaceship {
  constructor(x, y, speed=20, capacity=100, colonist_capacity=2) {
    this.x = x;
    this.y = y;
    this.targetX = x;
    this.targetY = y;
    this.moving = false;
    this.speed = speed; // Speed of the spaceship
    this.capacity = capacity; // Maximum capacity for resources
    this.colonist_capacity = colonist_capacity;
    this.resources = {}; // Resources carried by the spaceship
    this.colonists = []; // Colonists on board
    this.landed = false; // Whether the spaceship is landed on a planet
    this.landedPlanet = null; // The planet the spaceship is landed on
    this.angle = null;
		this.rot_angle = 0;
  }

  move() {
    if (this.moving) {
      const dx = this.targetX - this.x;
      const dy = this.targetY - this.y;
      const dist = Math.sqrt(dx * dx + dy * dy);

      if (dist > this.speed) {
        this.x += (dx / dist) * this.speed;
        this.y += (dy / dist) * this.speed;
				this.rot_angle = Math.atan2(dy, dx);
      } else {
        this.x = this.targetX;
        this.y = this.targetY;
        this.moving = false;
				if(this.landedPlanet){
					this.landed=true;
					this.landedPlanet.spaceships.push(this);
					this.rot_angle = this.angle+Math.PI/2;
					if(!this.landedPlanet.buildings.find(b => b.type === "base")){
						for(let c of this.landedPlanet.colonists){
							if(!c.base){
								c.base=this;
								if(c.state=="idle" && c.resources){
									c.state="to_base";
									c.moving=true;
								}
							}
						}
					}
				}
      }
    }
  }

  checkSelected(x, y){
     if(Math.sqrt((this.x -x)**2 + (this.y -y)**2)<50){
	     selectedSpaceship = this;
	     if(this.landed && this.landedPlanet.selectedColonist){
		     this.embarkColonist(this.landedPlanet.selectedColonist)
	     }
	     return true;
     }
     return false;
  }

  handleSpaceshipClick(x, y){
		for(let p of planets){
		//check if we clicked inside a planet
		    const dx = x - p.center.x;
		    const dy = y - p.center.y;
		    const clickDist = Math.sqrt(dx * dx + dy * dy);
		    const angle = Math.atan2(dy, dx)%(Math.PI*2);
		    const surfaceR = p.planetRadius(angle);
		    if ((clickDist) < (surfaceR + 500)) {
			    this.landOnPlanet(p, angle);
			    selectedSpaceship = null;
			    return true
			}
		}
		//else move in space
		this.targetX = x;
		this.targetY = y;
		this.moving = true;
		if(this.landed){
			this.takeOff();
		}
		selectedSpaceship = null;
  }

  landOnPlanet(planet, angle) {
    var pos = planet.getSurfacePosition(angle)
    //this.landed = true;
    this.landedPlanet = planet;
    this.targetX = pos.x;
    this.targetY = pos.y;
    this.moving = true;
    this.angle = angle;
  }

  takeOff() {
    this.landedPlanet.spaceships = this.landedPlanet.spaceships.filter(x=>x!=this);
		this.landedPlanet.colonists.forEach(c=>{
			if(c.base==this){
				c.base=null;
			}
		});
    this.landed = false;
    this.landedPlanet = null;
    this.angle = null;
  }

  embarkColonist(colonist) {
    if (this.colonists.length < this.capacity) {
      this.colonists.push(colonist);
      this.landedPlanet.colonists = this.landedPlanet.colonists.filter(c => c !== colonist);
    }
  }

  disembarkColonist(colonist, planet) {
    const index = this.colonists.indexOf(colonist);
    if (index !== -1) {
      this.colonists.splice(index, 1);
      planet.colonists.push(colonist);
      colonist.currentAngle = this.angle +0.01;
      colonist.angle = this.angle +0.01;
      colonist.base = planet.buildings.find(b => b.type === "base");
      if(! colonist.base){
	      colonist.base = this;
      }
    }
  }

	disembarkAll(){
		if(this.landed){
			for (let c of this.colonists){
				this.disembarkColonist(c, this.landedPlanet);
			}
		}
	}
	

  embarkResources(resources) {
    for (let type in resources) {
      var addedResources = Math.min( resources[type], this.capacity);
      this.resources[type] = (this.resources[type] || 0) + addedResources;
      this.capacity -= addedResources;
    }
  }

  disembarkResources(resources, planet) {
    for (let type in resources) {
      if (this.resources[type] >= resources[type]) {
        this.resources[type] -= resources[type];
        planet.buildings.find(b => b.type === "base").resources[type] = (planet.buildings.find(b => b.type === "base").resources[type] || 0) + resources[type];
      }
    }
  }

  draw() {
    if(this.moving){
			this.move();
    }
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.fillStyle = "#ffffff";
    ctx.beginPath();
    ctx.moveTo(0, -30);
    ctx.lineTo(30, 30);
    ctx.lineTo(-30, 30);
    ctx.closePath();
    ctx.fill();
		ctx.rotate(this.rot_angle);
    ctx.restore();
  }
}


class Factory {
  constructor(type, inputResources, outputResources, requiredResources, base) {
    this.type = type;
    this.inputResources = inputResources;
    this.outputResources = outputResources;
    this.requiredResources = requiredResources;//for the construction
    this.base = base;
    this.workers = 0;
  }

  addWorker() {
    this.workers += 1;
  }

  removeWorker() {
    this.workers = Math.max(0, this.workers - 1);
  }


  process(baseResources) {
    let canProcess = true;
    for (let resource in this.inputResources) {
      if (baseResources[resource] < this.inputResources[resource] * this.workers) {
        canProcess = false;
        break;
      }
    }

    if (canProcess) {
      for (let resource in this.inputResources) {
        baseResources[resource] -= this.inputResources[resource] * this.workers;
      }
      for (let resource in this.outputResources) {
        baseResources[resource] = (baseResources[resource] || 0) + this.outputResources[resource] * this.workers;
      }
    }
  }
}

class Farm extends Factory {
  constructor(base) {
    super('farm', { water: 0.02 }, { food: 0.01 }, {structium : 50}, base);
  }
}
class Lab extends Factory {
  constructor(base) {
    super('lab', { }, { science: 0.01 }, {structium : 50}, base);
  }
}
class Solar_panels extends Factory {
  constructor(base) {
    super('solar_panels', { }, { energy: 0.01 }, {copper: 50}, base);
  }
}
class Mine extends Factory {
  constructor(base) {
    super('mine', {energy: 0.04}, { copper: 0.01, iron: 0.01, gold: 0.01}, {structium : 100, iron: 50}, base);
  }
}


// ===== ⭐ MODULAR: Planet Class =====
class Planet {
  constructor(x, y, baseRadius = 120, amplitude = 20) {
    this.type = planetTypes[Math.floor(Math.random() * planetTypes.length)];
    this.color = planetColors[this.type];
    this.center = { x, y };
    this.baseRadius = baseRadius;
    this.amplitude = amplitude;
    this.offset1 = Math.random() * Math.PI * 2;
    this.offset2 = Math.random() * Math.PI * 2;
    this.colonists = [];
    this.resources = [];
    this.buildings = [];
    this.selectedColonist = null;
    this.spaceships = []; // Reference to the spaceship if landed

    this.mountainPeaks = [
      Math.random() * Math.PI * 2,
      Math.random() * Math.PI * 2,
      Math.random() * Math.PI * 2,
    ];

    this.mountainHeights = [
      this.baseRadius * 0.2 * Math.random(),
      this.baseRadius * 0.2 * Math.random(),
      this.baseRadius * 0.2 * Math.random(),
    ];

    let numResources = Math.floor(this.baseRadius / 100) + 2 + Math.random() * 5;
    for (let i = 0; i < numResources; i++) {
      let biasedList = resourceBias[this.type];
      let type = biasedList[Math.floor(Math.random() * biasedList.length)];
      let angle = Math.random() * Math.PI * 2;
      let stock = 200 + Math.floor(Math.random() * 300); // More stock
      this.spawnResource(type, angle, stock);
    }
  }

  spawnBase(angle) {
    this.buildings.push({
      type: "base",
      number_buldings: 1,
      hp: 5000,
      angle: angle,
      spawn_angle: angle - 100/this.baseRadius,
      resources: {},
      onClick: () => {}
    });
  }

  spawnResource(type, angle, stock) {
    this.resources.push({
      type,
      angle,
      stock,
      list_miners:[]
    });
  }

  createColonist(angle) {
    return {
      angle,
      currentAngle: angle,
      targetAngle: angle,
      moving: false,
      carrying: {},
      capacity: 20,
      moveSpeed: 0.01,
      hp: 100,
      attack: 1,
      miningSpeed: { "iron": 2 },
      state: "idle",
      targetResource: null,
      base: this.buildings.find(b => b.type === "base"),
    };
  }

  planetRadius(angle) {
    let r = this.baseRadius;
    angle = angle%(Math.PI*2);
    // Sum of sinusoidal functions
    r += this.amplitude * (
      0.7 * Math.sin(this.baseRadius/100 * angle + this.offset1) +
      0.5 * Math.sin(3 * this.baseRadius/500 * angle + this.offset1) +
      0.3 * Math.sin(7 * this.baseRadius/500* angle + this.offset2) +
      0.2 * Math.sin(13 * this.baseRadius/500 * angle + this.offset1 * 0.5) +
      0.1 * Math.sin(13 * this.baseRadius/500 * angle + this.offset2 * 0.5)
    );

    // Mountain-like features using a smooth ridge pattern
    for (let i = 0; i < 3; i++) {
      let peakAngle = this.mountainPeaks[i];
      let dist = Math.abs(Math.atan2(Math.sin(angle - peakAngle), Math.cos(angle - peakAngle)));
      let step = 1 - Math.min(1, dist / 0.3); // smoother than a hard step
      r += this.mountainHeights[i] * step ** 3; // cubic to smooth peak
    }

    return r;
  }

  getSurfacePosition(angle) {
    const r = this.planetRadius(angle%(Math.PI*2));
    return {
      x: this.center.x + r * Math.cos(angle),
      y: this.center.y + r * Math.sin(angle),
      angle: angle%(Math.PI*2),
      radius: r,
    };
  }

  drawImageAt(angle, size, drawFn) {
    const pos = this.getSurfacePosition(angle);
    const pos2 = this.getSurfacePosition(angle+0.01);
    ctx.save();
    ctx.translate(pos.x, pos.y);
    const rot_angle = Math.atan2(pos2.y - pos.y, pos2.x -pos.x)
    ctx.rotate(rot_angle);
    drawFn();
    ctx.restore();
  }

  draw() {
    ctx.save();
    ctx.translate(this.center.x, this.center.y);
    ctx.beginPath();
    const steps = 360;
    for (let i = 0; i <= steps; i++) {
      let angle = (i / steps) * Math.PI * 2;
      let r = this.planetRadius(angle);
      let x = r * Math.cos(angle);
      let y = r * Math.sin(angle);
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.closePath();
    ctx.fillStyle = this.color;
    ctx.fill();
    ctx.strokeStyle = lightenColor(this.color, 20);
    ctx.lineWidth = 2 / zoom;
    ctx.stroke();
    ctx.restore();

    this.buildings.forEach(b => this.drawObject(b, "building"));
    this.resources.forEach(r => this.drawObject(r, "resource"));
    this.colonists.forEach(c => {
      this.updateColonist(c);
      this.drawObject(c, "colonist");
    });

  }

  drawObject(obj, type) {
    this.drawImageAt(obj.currentAngle ?? obj.angle, 20, () => {
      if (type === "colonist") {
        ctx.fillStyle = obj.color ?? "#e9c46a";
        ctx.beginPath();
        ctx.arc(0, 0, 10, 0, Math.PI * 2);
        ctx.fill();
        if (obj === this.selectedColonist) {
          ctx.strokeStyle = "#fff";
          ctx.lineWidth = 2;
          ctx.stroke();
        }
      } else if (type === "resource") {
        ctx.fillStyle = resources_colors[obj.type]
        ctx.beginPath();
        ctx.rect(-8, -8, 16, 16);
        ctx.fill();
      } else if (type === "building") {
        var img1 = new Image();
        img1.src=`${obj.type}.png`
        ctx.drawImage(img1, -50, -450, 100, 500)
      }
    });
  }

  updateColonist(c) {
    if (c.moving) {
      let diff = (c.targetAngle - c.currentAngle) % (Math.PI * 2);
      if (diff > Math.PI) {
        diff = 2 * Math.PI - diff;
      }
      diff = Math.atan2(Math.sin(diff), Math.cos(diff));
      if (Math.abs(diff) > c.moveSpeed / this.baseRadius * 100) {
        c.currentAngle += Math.sign(diff) * c.moveSpeed / this.baseRadius * 100;
        c.angle = c.currentAngle % (Math.PI * 2);
      } else {
        c.currentAngle = c.targetAngle % (Math.PI * 2);
        c.angle = c.currentAngle % (Math.PI * 2);
        c.moving = false;
      }
      return;
    }

    // Mining logic
    if (c.state === "mining" && c.targetResource) {
      if (c.targetResource.stock > 0) {
        let amount = Math.min(c.miningSpeed[c.targetResource.type] ?? 1, c.capacity, c.targetResource.stock);
        c.capacity -= amount;
        c.targetResource.stock -= amount;
        var old_amount = c.carrying[c.targetResource.type] ?? 0;
        c.carrying[c.targetResource.type] = old_amount + amount;
        if (c.capacity <= 0) {
          if (!(c.base) || ((c.base instanceof Spaceship) && (c.base.capacity <= 0))) {
            c.state = "idle";
            c.targetAngle = c.angle + 0.1;
            c.moving = true;
          } else {
            c.state = "to_base";
            c.targetAngle = c.base.angle % (Math.PI * 2);
            c.moving = true;
          }
        }
      }
      // REMOVE depleted resource
      if (c.targetResource.stock <= 0) {
        const index = this.resources.indexOf(c.targetResource);
        c.targetResource.list_miners.forEach(c2 => {
          c2.state = "idle";
          c2.targetAngle = c2.base.angle % (Math.PI * 2);
          c2.targetResource = null;
        });
        if (index !== -1) this.resources.splice(index, 1);
        c.targetResource = null;
        c.state = "to_base";
        c.targetAngle = c.base.angle % (Math.PI * 2);
      }
    } else if (c.state === "to_base" && !c.moving) {
      // drop off
      if (c.base instanceof Spaceship) {
        c.base.embarkResources(c.carrying);
      } else {
        for (let resource_type in c.carrying) {
          var base_resource_quantity = c.base.resources[resource_type] ?? 0;
          c.base.resources[resource_type] = base_resource_quantity + c.carrying[resource_type];
        }
      }
      c.carrying = {};
      c.capacity = 20;
      if (c.targetResource) {
        c.targetAngle = c.targetResource.angle % (Math.PI * 2);
        c.state = "mining";
        c.moving = true;
      } else {
        c.state = "idle";
      }
    }
  }

  handleRightClick(x, y) {
    const dx = x - this.center.x;
    const dy = y - this.center.y;
    const clickDist = Math.sqrt(dx * dx + dy * dy);
    const angle = Math.atan2(dy, dx)%(Math.PI*2);
    const surfaceR = this.planetRadius(angle);

    if (Math.abs(clickDist - surfaceR) < 500) {
      const pos = this.getSurfacePosition(angle);

      // Move colonist or assign task
      if (this.selectedColonist) {
        var any_close = false;
        for (let r of this.resources) {
          const rPos = this.getSurfacePosition(r.angle);
          if (Math.hypot(rPos.x - x, rPos.y - y) < 50) {
            any_close = true;
            if(this.selectedColonist.targetResource){
              let r2=this.selectedColonist.targetResource;
              r2.list_miners = r2.list_miners.filter(x => x !== this.selectedColonist);
            }
            if (this.selectedColonist.assignedFactory) {
              this.selectedColonist.assignedFactory.removeWorker();
            }
            this.selectedColonist.state = "mining";
            this.selectedColonist.targetResource = r;
            r.list_miners.push(this.selectedColonist);
            this.selectedColonist.targetAngle = r.angle%(Math.PI*2);;
            this.selectedColonist.moving = true;
            this.selectedColonist = null;
            return true;
          }
        }
        for (let b of this.buildings) {
          const bPos = this.getSurfacePosition(b.angle);
          if (Math.hypot(bPos.x - x, bPos.y - y) < 50 && b.factory) {
            any_close = true;
            if (this.selectedColonist.assignedFactory) {
              this.selectedColonist.assignedFactory.removeWorker();
            }
            this.selectedColonist.assignedFactory = b.factory;
            b.factory.addWorker();
            this.selectedColonist.state = "working";
            this.selectedColonist.targetAngle = b.angle;
            this.selectedColonist.moving = true;
            this.selectedColonist = null;
            return true;
          }
        }

        if(this.selectedColonist.targetResource){
            let r2=this.selectedColonist.targetResource;
            r2.list_miners = r2.list_miners.filter(x => x !== this.selectedColonist);
        }
        if (this.selectedColonist.assignedFactory) {
          this.selectedColonist.assignedFactory.removeWorker();
        }
        this.selectedColonist.state = "idle"
        this.selectedColonist.targetResource = null;
        this.selectedColonist.targetAngle = angle;
        this.selectedColonist.moving = true;
        this.selectedColonist = null;
        return true;
      }
    }
return false;
  }

  handleClick(x, y) {
    const dx = x - this.center.x;
    const dy = y - this.center.y;
    const clickDist = Math.sqrt(dx * dx + dy * dy);
    const angle = Math.atan2(dy, dx)%(Math.PI*2);
    const surfaceR = this.planetRadius(angle);

    if (Math.abs(clickDist - surfaceR) < 500) {
      const pos = this.getSurfacePosition(angle);
	    // Click colonist
	    for (let c of this.colonists) {
	      const cPos = this.getSurfacePosition(c.currentAngle);
	      if (Math.hypot(cPos.x - x, cPos.y - y) < 50) {
	        this.selectedColonist = c;
	        return true;
	      }
	    }

	    // Click building
	    for (let b of this.buildings) {
	      const bPos = this.getSurfacePosition(b.angle);
	      //TODO replace this with angular distance
	      if (Math.hypot(bPos.x - x, bPos.y - y) < 50) {
	        if(b.type == "base"){
	          selectedBase = b;
	        }
	        this.selectedColonist = null;
	        if (b.onClick) b.onClick();
	        return true;
	      }
	    }

    return false;
  }

}

function buildHabitation() {
  if (!selectedBase) return;
  const planet = planets.find(p => p.buildings.includes(selectedBase));

  const structium = selectedBase.resources.structium || 0;

  if (structium >=50) {
    selectedBase.resources.structium -= 50;

    selectedBase.number_buldings +=1

    planet.buildings.push({
      type: "hab",
      angle: selectedBase.spawn_angle,
      hp: 1000
    });
    selectedBase.spawn_angle = selectedBase.spawn_angle + selectedBase.number_buldings * (-1)**(selectedBase.number_buldings) *100/planet.baseRadius
  } else {
    alert("Not enough resources to build a habitation module!");
  }
}

// List of unlocked factories
var unlockedFactories = {"farm":Farm, "lab":Lab, "mine": Mine, "solar_panels":Solar_panels};

// Function to build a factory
function buildFactory(factoryClass) {
  if (!selectedBase) return;
  const planet = planets.find(p => p.buildings.includes(selectedBase));

  const factory = new factoryClass(selectedBase);
  const requiredResources = factory.requiredResources;

  let canBuild = true;
  for (let resource in requiredResources) {
    if ((selectedBase.resources[resource] || 0) < requiredResources[resource]) {
      canBuild = false;
      alert(`Not enough ${resource} : ${selectedBase.resources[resource] || 0}/${requiredResources[resource]}`)
      break;
    }
  }

  if (canBuild) {
    for (let resource in requiredResources) {
      selectedBase.resources[resource] -= requiredResources[resource];
    }

    selectedBase.number_buldings +=1
    planet.buildings.push({
      type: factory.type,
      angle: selectedBase.spawn_angle,
      hp: 1000,
      factory: factory
    });
    selectedBase.spawn_angle = selectedBase.spawn_angle + selectedBase.number_buldings * (-1)**(selectedBase.number_buldings) *100/planet.baseRadius
  } else {
    alert("Not enough resources to build this factory!");
  }
}


// ===== ⭐ MODULAR: Create Multiple Planets =====
function generatePlanets(n = 5) {
  const planets = [];
  const maxTries = 500;

  for (let i = 0; i < n; i++) {
    let tries = 0;
    while (tries < maxTries) {
      let baseRadius = 500 + Math.random() * 2000;
      let amplitude = 20 + Math.random() * 20;
      let x = Math.random() * 30000 - 15000;
      let y = Math.random() * 12000 - 6000;

      const newPlanet = new Planet(x, y, baseRadius, amplitude);
      let tooClose = planets.some(p => {
        let dx = p.center.x - newPlanet.center.x;
        let dy = p.center.y - newPlanet.center.y;
        let dist = Math.sqrt(dx * dx + dy * dy);
        return dist < 2 * (p.baseRadius + newPlanet.baseRadius);
      });

      if (!tooClose) {
        planets.push(newPlanet);
        break;
      }
      tries++;
    }
  }
  return planets;
}

var planets = generatePlanets(5);
planets[0].spawnBase(Math.random() * Math.PI * 2);
var base_pos = planets[0].getSurfacePosition(planets[0].buildings[0].angle)
planets[0].buildings[0].resources = {
  food: 100,
  water: 100
}
panX = document.querySelector("body").clientWidth/2 - base_pos.x * zoom;
panY = document.querySelector("body").clientHeight/2 - base_pos.y * zoom


const uiPanel = document.getElementById("uiPanel");
let selectedBase = null;
let selectedBuilding = null;
let selectedSpaceship = null;


var screenToWorld = (sx, sy) => ({
  x: (sx - panX)/zoom,
  y: (sy - panY)/zoom,
});

canvas.addEventListener("click", (e) => {
  const { x, y } = screenToWorld(e.clientX, e.clientY);
  for (let spaceship of spaceships) {
    //actions to select a spaceship
    if (spaceship.checkSelected(x, y)) return;
  }
  for (let planet of planets) {//actions to interact with objects on planets including spaceship landed
    if (planet.handleClick(x, y)) return;
  }


});
canvas.addEventListener("contextmenu", (e) => {
	e.preventDefault();
  const { x, y } = screenToWorld(e.clientX, e.clientY);

  if (selectedSpaceship) {//actions when a spaceship is selected
    if (selectedSpaceship.handleSpaceshipClick(x, y)) return;
  }
  for (let planet of planets) {//actions to interact with objects on planets including spaceship landed
    if (planet.handleRightClick(x, y)) return;
  }


});

function spawnSpecialist(type) {
	console.log(type);
  if (!selectedBase) return;
  
  const planet = planets.find(p => p.buildings.includes(selectedBase));
  const food = selectedBase.resources.food || 0;
  const water = selectedBase.resources.water || 0;
  //5 colonists by habitation module + 10 by base
  const habs = 5 * planet.buildings.filter(b => b.type === "hab").length + 10 * planet.buildings.filter(b => b.type === "base").length;
  const colonists = planet.colonists.filter(c => c.base === selectedBase).length;

  if (food >= 10 && water >= 5 && colonists < habs) {
    selectedBase.resources.food -= 10;
    selectedBase.resources.water -= 5;

    const colonist = planet.createColonist(selectedBase.spawn_angle);
    if (type === "miner") {
      colonist.miningSpeed = { iron: 2, copper: 2 };
    } else if (type === "soldier") {
      colonist.miningSpeed = {};
      colonist.hp = 120;
      colonist.attack = 100;
      colonist.color = "#ff0000";
    }
    planet.colonists.push(colonist);
  } else {
    alert("Insufficient food, water, or housing space!");
  }

}



// ===== Animation Loop =====
function updateUIPanel() {
  const currentColonist = planets.find(p => p.selectedColonist)?.selectedColonist;

  if (currentColonist && lastUIState.ref !== currentColonist) {
    // Switch to colonist UI
    lastUIState = { type: "colonist", ref: currentColonist };
    selectedBase = null;
    selectedBuilding = null;
    selectedSpaceship = null;

    uiPanel.style.display = "block";
    uiPanel.innerHTML = `
      <strong>Colonist</strong><br>
      State: <span id="colonistState">${currentColonist.state}</span><br>
      Carrying:<br><ul id="colonistCarrying"></ul>
    `;
  } else if (selectedBase && lastUIState.ref !== selectedBase) {
    // Switch to base UI
    lastUIState = { type: "base", ref: selectedBase };
    planets.forEach(p => p.selectedColonist = null); // clear selection
    let planet = planets.find(p => p.buildings.includes(selectedBase));

    uiPanel.style.display = "block";
    uiPanel.innerHTML = `
      <strong>Base</strong><br>
      Resources:<br><ul id="baseResources"></ul>
      Colonists: ${planet.colonists.length}/${5 * planet.buildings.filter(b => b.type === "hab").length + 10 * planet.buildings.filter(b => b.type === "base").length}<br>
      Create colonist:<br>
      <button id="spawnSpecialist_miner">Create Miner</button>
      <button id="spawnSpecialist_soldier">Create Soldier</button> (10 food, 5 water)<br>
      Create buildings:<br>
      <button onclick="buildHabitation()">Build Habitation Module</button> (50 structium)<br>
    `;
    for(fact_type in unlockedFactories){
      let fact_class = unlockedFactories[fact_type];
      uiPanel.innerHTML +=`<button onclick="buildFactory(${capitalize(fact_type)})">Build ${capitalize(fact_type)}</button> (`;
      let requiredResources = (new fact_class("")).requiredResources;
      for(resource in requiredResources){
        uiPanel.innerHTML += `${requiredResources[resource]} ${resource}, `
      }
      uiPanel.innerHTML += ")<br>"
    }

    document.getElementById("spawnSpecialist_miner").onclick = () => spawnSpecialist('miner');
    document.getElementById("spawnSpecialist_soldier").onclick = () => spawnSpecialist('soldier');
  } else if (selectedBuilding && lastUIState.ref !== selectedBuilding) {
    // Switch to base UI
    lastUIState = { type: selectedBuilding.type, ref: selectedBuilding };
    planets.forEach(p => p.selectedColonist = null); // clear selection
    uiPanel.style.display = "block";
    uiPanel.innerHTML = `
      <strong>${selectedBuilding.type}</strong><br>
    `;
    if(selectedBuilding.factory){
      uiPanel.innerHTML+=`Number of workers: ${selectedBuilding.factory.workers}<br>`
    }
  } else if (selectedSpaceship && lastUIState.ref !== selectedSpaceship) {
    // Switch to spaceship UI
    lastUIState = { type: "spaceship", ref: selectedSpaceship };
    planets.forEach(p => p.selectedColonist = null); // clear selection
    selectedBase = null;
    selectedBuilding = null;

    uiPanel.style.display = "block";
    uiPanel.innerHTML = `
      <strong>Spaceship</strong><br>
      Resources:<br><ul id="spaceshipResources"></ul>
			<p style="visibility:hidden;" id="placeholderBaseResources">Base Resources:<br><ul id="baseResources"></ul></p>
      Remaining space: ${selectedSpaceship.capacity}<br>
      Colonists: ${selectedSpaceship.colonists.length}/${selectedSpaceship.colonist_capacity}<br>
			<button id="disembarkAll" style="visibility:hidden;">Disembark colonists</button><br>
    `;
		if (selectedSpaceship.landed && selectedSpaceship.landedPlanet.buildings.find(b => b.type === "base")) {
      const base = selectedSpaceship.landedPlanet.buildings.find(b => b.type === "base");
      document.getElementById("placeholderBaseResources").style.display = "block";

      uiPanel.innerHTML += `
        <h3>Transfer Resources</h3>
        <form id="resourceTransferForm">
          <label for="resourceType">Resource Type:</label>
          <select id="resourceType">
            <option value="">Select Resource</option>
          </select><br>
          <label for="transferAmount">Amount:</label>
          <input type="number" id="transferAmount" min="1"><br>
          <button type="button" onclick="transferResources()">Transfer to Base</button>
          <button type="button" onclick="transferResources(true)">Transfer to Spaceship</button>
        </form>
      `;

      // Populate the resource type dropdown
      const resourceTypeSelect = document.getElementById("resourceType");
      for (let type in base.resources) {
          const option = document.createElement("option");
          option.value = type;
          option.textContent = type;
          resourceTypeSelect.appendChild(option);
        
      }
  	for (let type in selectedSpaceship.resources) {
          const option = document.createElement("option");
          option.value = type;
          option.textContent = type;
          resourceTypeSelect.appendChild(option);
        
      }
  }
		
  } else if (!currentColonist && !selectedBase && !selectedBuilding && !selectedSpaceship) {
    // Nothing selected
    if (lastUIState.type !== null) {
      uiPanel.style.display = "none";
      uiPanel.innerHTML = "";
      lastUIState = { type: null, ref: null };
    }
  }

  // If panel is showing, update dynamic parts
  if (lastUIState.type === "colonist") {
    const c = lastUIState.ref;
    document.getElementById("colonistState").textContent = c.state;
    const ul = document.getElementById("colonistCarrying");
    ul.innerHTML = "";
    for (let type in c.carrying) {
      ul.innerHTML += `<li>${type}: ${c.carrying[type]}</li>`;
    }
  } else if (lastUIState.type === "base") {
    const b = lastUIState.ref;
    const ul = document.getElementById("baseResources");
    ul.innerHTML = "";
    for (let type in b.resources) {
      ul.innerHTML += `<li>${type}: ${b.resources[type]}</li>`;
    }
  } else if (lastUIState.type === "spaceship") {
    const s = lastUIState.ref;
    const ul = document.getElementById("spaceshipResources");
    ul.innerHTML = "";
    for (let type in s.resources) {
      ul.innerHTML += `<li>${type}: ${s.resources[type]}</li>`;
    }
		if(s.landed){
			document.getElementById("disembarkAll").style.visibility = "visible";
			document.getElementById("disembarkAll").onclick = function(e){
			  console.log(e);
			  s.disembarkAll();
			  selectedSpaceship = null;
			  updateUIPanel();
			  selectedSpaceship = s;
			  updateUIPanel();
			selectedSpaceship = null;
			}
		}else{
			document.getElementById("disembarkAll").style.visibility = "hidden";
		}
    if((s.landed) && (s.landedPlanet.buildings.find(b=>b.type==="base"))){
			
			var base = s.landedPlanet.buildings.find(b=>b.type==="base");
			document.getElementById("placeholderBaseResources").style.visibility = "visible";
			var ul2 = document.getElementById("baseResources");
    	ul2.innerHTML = "";
			for (let type in base.resources) {
	      ul2.innerHTML += `<li>${type}: ${base.resources[type]}</li>`;
	    }
    }
		//TODO add resource transfert UI
  }
}

function transferResources(toSpaceship = false) {
  const resourceType = document.getElementById("resourceType").value;
  const transferAmount = parseInt(document.getElementById("transferAmount").value, 10);

  if (!resourceType || isNaN(transferAmount) || transferAmount <= 0) {
    alert("Please select a valid resource type and amount.");
    return;
  }

  if (toSpaceship) {
    // Transfer from base to spaceship
    const base = selectedSpaceship.landedPlanet.buildings.find(b => b.type === "base");
    if (base.resources[resourceType] >= transferAmount) {
      base.resources[resourceType] -= transferAmount;
      selectedSpaceship.resources[resourceType] = (selectedSpaceship.resources[resourceType] || 0) + transferAmount;
    } else {
      alert("Not enough resources in the base.");
    }
  } else {
    // Transfer from spaceship to base
    if (selectedSpaceship.resources[resourceType] >= transferAmount) {
      selectedSpaceship.resources[resourceType] -= transferAmount;
      const base = selectedSpaceship.landedPlanet.buildings.find(b => b.type === "base");
      base.resources[resourceType] = (base.resources[resourceType] || 0) + transferAmount;
    } else {
      alert("Not enough resources in the spaceship.");
    }
  }
}


function update() {
  ctx.setTransform(1, 0, 0, 1, 0, 0); // reset any transform
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Apply global camera transform
  ctx.setTransform(zoom, 0, 0, zoom, panX, panY);

  for (let planet of planets) {
    planet.draw();
    for (let building of planet.buildings) {
      if (building.factory) {
        building.factory.process(building.factory.base.resources);
      }
    }
  }
  for (let spaceship of spaceships){
	spaceship.draw()
  }
  updateUIPanel();
  requestAnimationFrame(update);
}

// Create a spaceship
var spaceships = [new Spaceship(1000, 1000)];
update();
</script>
</body>
</html>
