<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Modular Multi-Planet View</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; background: #000; }
  </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="uiPanel" style="
  position: absolute;
  top: 20px;
  left: 20px;
  background: rgba(20,20,30,0.9);
  color: white;
  padding: 10px 15px;
  border-radius: 10px;
  font-family: sans-serif;
  font-size: 14px;
  display: none;
  z-index: 10;
  min-width: 200px;
">
</div>
<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
resizeCanvas();
window.addEventListener("resize", resizeCanvas);

function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}

// Global view transforms
let zoom = 1;
let panX = 0, panY = 0;
let isDragging = false;
let lastMouseX = 0, lastMouseY = 0;
let list_resources = ['iron', 'copper', 'food', 'water', 'silicon', 'gold', 'crystal'];
let resources_colors = {
  iron: "#99aaad",
  copper: "#f2a049",
  food: "#07ab2a",
  water: "#0048ff",
  silicon: "#cccccc",
  gold: "#ffd700",
  crystal: "#00ffff"
};

var planetTypes = ['desert', 'jungle', 'lava', 'ice', 'rocky'];

var planetColors = {
  desert: '#d2b48c',
  jungle: '#228b22',
  lava: '#ff4500',
  ice: '#add8e6',
  rocky: '#888888'
};

var resourceBias = {
  desert: ['iron', 'iron','silicon', 'silicon', 'silicon', 'gold', 'gold', 'food'],
  jungle: ['food','food','food','food','water','water', 'water', 'crystal'],
  lava: ['iron', 'iron', 'iron', 'copper', 'gold'],
  ice: ['water', 'water', 'water', 'water', 'crystal', 'crystal', 'silicon'],
  rocky: ['iron','iron', 'copper', 'copper', 'silicon', 'silicon', 'water']
};

let lastUIState = { type: null, ref: null };

canvas.addEventListener("wheel", (e) => {
  e.preventDefault();
  
  const mouseX = e.clientX;
  const mouseY = e.clientY;

  const worldX = (mouseX - panX) / zoom;
  const worldY = (mouseY - panY) / zoom;

  const zoomFactor = e.deltaY < 0 ? 1.1 : 1 / 1.1;
  zoom *= zoomFactor;

  // Adjust pan to keep zoom centered at mouse
  panX = mouseX - worldX * zoom;
  panY = mouseY - worldY * zoom;
});


canvas.addEventListener("mousedown", (e) => {
  isDragging = true;
  lastMouseX = e.clientX;
  lastMouseY = e.clientY;
});
canvas.addEventListener("mousemove", (e) => {
  if (isDragging) {
    let dx = e.clientX - lastMouseX;
    let dy = e.clientY - lastMouseY;
    panX += dx;
    panY += dy;
    lastMouseX = e.clientX;
    lastMouseY = e.clientY;
  }
});
canvas.addEventListener("mouseup", () => isDragging = false);
canvas.addEventListener("mouseleave", () => isDragging = false);

document.onkeydown=function(e){
  if(e.key === "Escape"){
    planets.forEach(p=>{
      p.selectedColonist=null;
    });
    selectedBase = null;
    
  }
  if(e.key === "i"){
    //find an idle colonist
    planets.forEach(p=>{
      p.colonists.filter(x => x !== p.selectedColonist).forEach(c=>{
        if((c.state === "idle")){
          p.selectedColonist = c;
          return
        }
      });
      return
    });
    
  }
  if(e.key === "+"){
	zoom*=1.1;
    }
    if(e.key === "-"){
      	zoom/=1.1;
    }
}

function lightenColor(hex, percent) {
  let num = parseInt(hex.replace('#', ''), 16),
      amt = Math.round(2.55 * percent),
      R = (num >> 16) + amt,
      G = (num >> 8 & 0x00FF) + amt,
      B = (num & 0x0000FF) + amt;
  return "#" + (
    0x1000000 +
    (R < 255 ? R<1?0:R : 255)*0x10000 +
    (G < 255 ? G<1?0:G : 255)*0x100 +
    (B < 255 ? B<1?0:B : 255)
  ).toString(16).slice(1);
}

class Factory {
  constructor(type, inputResources, outputResources, requiredResources, base) {
    this.type = type;
    this.inputResources = inputResources;
    this.outputResources = outputResources;
    this.requiredResources = requiredResources;//for the construction
    this.base = base;
    this.workers = 0;
  }

  addWorker() {
    this.workers += 1;
  }

  removeWorker() {
    this.workers = Math.max(0, this.workers - 1);
  }


  process(baseResources) {
    let canProcess = true;
    for (let resource in this.inputResources) {
      if (baseResources[resource] < this.inputResources[resource] * this.workers) {
        canProcess = false;
        break;
      }
    }

    if (canProcess) {
      for (let resource in this.inputResources) {
        baseResources[resource] -= this.inputResources[resource] * this.workers;
      }
      for (let resource in this.outputResources) {
        baseResources[resource] = (baseResources[resource] || 0) + this.outputResources[resource] * this.workers;
      }
    }
  }
}

class Farm extends Factory {
  constructor(base) {
    super('farm', { water: 2 }, { food: 1 }, {silicon : 50}, base);
  }
}


// ===== ⭐ MODULAR: Planet Class =====
class Planet {
  constructor(x, y, baseRadius = 120, amplitude = 20) {
    this.type = planetTypes[Math.floor(Math.random() * planetTypes.length)];
    this.color = planetColors[this.type];
    this.center = { x, y };
    this.baseRadius = baseRadius;
    this.amplitude = amplitude;
    this.offset1 = Math.random() * Math.PI * 2;
    this.offset2 = Math.random() * Math.PI * 2;
    this.colonists = [];
    this.resources = [];
    this.buildings = [];
    this.selectedColonist = null;

    this.mountainPeaks = [
      Math.random() * Math.PI * 2,
      Math.random() * Math.PI * 2,
      Math.random() * Math.PI * 2,
    ];

    this.mountainHeights = [
      this.baseRadius * 0.2 * Math.random(),
      this.baseRadius * 0.2 * Math.random(),
      this.baseRadius * 0.2 * Math.random(),
    ];

    
    let numResources = Math.floor(this.baseRadius / 100) + 2 + Math.random() * 5;
    for (let i = 0; i < numResources; i++) {
      let biasedList = resourceBias[this.type];
      let type = biasedList[Math.floor(Math.random() * biasedList.length)];
      let angle = Math.random() * Math.PI * 2;
      let stock = 200 + Math.floor(Math.random() * 300); // More stock
      this.spawnResource(type, angle, stock);
    }

  }

  spawnBase(angle) {
    this.buildings.push({
      type: "base",
      number_buldings: 1,
      hp: 5000,
      angle: angle,
      spawn_angle: angle - 100/this.baseRadius,
      resources: {},
      onClick: () => {
        
      }
    });
  }

  spawnResource(type, angle, stock) {
    this.resources.push({
      type,
      angle,
      stock,
      list_miners:[]
    });
  }

  createColonist(angle) {
    return {
      angle,
      currentAngle: angle,
      targetAngle: angle,
      moving: false,
      carrying: {},
      capacity: 20,
      moveSpeed: 0.01,
      hp: 100,
      attack: 1,
      miningSpeed: { "iron": 2 },
      state: "idle",
      targetResource: null,
      base: this.buildings.find(b => b.type === "base"),
    };
  }

  planetRadius(angle) {
    let r = this.baseRadius;
    angle = angle%(Math.PI*2);
    // Sum of sinusoidal functions
    r += this.amplitude * (
      0.7 * Math.sin(this.baseRadius/100 * angle + this.offset1) +
      0.5 * Math.sin(3 * this.baseRadius/500 * angle + this.offset1) +
      0.3 * Math.sin(7 * this.baseRadius/500* angle + this.offset2) +
      0.2 * Math.sin(13 * this.baseRadius/500 * angle + this.offset1 * 0.5) +
      0.1 * Math.sin(13 * this.baseRadius/500 * angle + this.offset2 * 0.5)
    );

    // Mountain-like features using a smooth ridge pattern
    for (let i = 0; i < 3; i++) {
      let peakAngle = this.mountainPeaks[i];
      let dist = Math.abs(Math.atan2(Math.sin(angle - peakAngle), Math.cos(angle - peakAngle)));
      let step = 1 - Math.min(1, dist / 0.3); // smoother than a hard step
      r += this.mountainHeights[i] * step ** 3; // cubic to smooth peak
    }

    return r;
  }

  getSurfacePosition(angle) {
    const r = this.planetRadius(angle%(Math.PI*2));
    return {
      x: this.center.x + r * Math.cos(angle),
      y: this.center.y + r * Math.sin(angle),
      angle: angle%(Math.PI*2),
      radius: r,
    };
  }

  drawImageAt(angle, size, drawFn) {
    const pos = this.getSurfacePosition(angle);
  	const pos2 = this.getSurfacePosition(angle+0.01);
    ctx.save();
    ctx.translate(pos.x, pos.y);
  	const rot_angle = Math.atan2(pos2.y - pos.y, pos2.x -pos.x)
    ctx.rotate(rot_angle);
    drawFn();
    ctx.restore();
  }

  draw() {
    ctx.save();
    ctx.translate(this.center.x, this.center.y);
    ctx.beginPath();
    const steps = 360;
    for (let i = 0; i <= steps; i++) {
      let angle = (i / steps) * Math.PI * 2;
      let r = this.planetRadius(angle);
      let x = r * Math.cos(angle);
      let y = r * Math.sin(angle);
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.closePath();
    ctx.fillStyle = this.color; 
    ctx.fill();
    ctx.strokeStyle = lightenColor(this.color, 20);
    ctx.lineWidth = 2 / zoom;
    ctx.stroke();
    ctx.restore();

    this.buildings.forEach(b => this.drawObject(b, "building"));
    this.resources.forEach(r => this.drawObject(r, "resource"));
    this.colonists.forEach(c => {
      this.updateColonist(c);
      this.drawObject(c, "colonist");
    });
  }

  drawObject(obj, type) {
    this.drawImageAt(obj.currentAngle ?? obj.angle, 20, () => {
      if (type === "colonist") {
        ctx.fillStyle = obj.color ?? "#e9c46a";
        ctx.beginPath();
        ctx.arc(0, 0, 10, 0, Math.PI * 2);
        ctx.fill();
        if (obj === this.selectedColonist) {
          ctx.strokeStyle = "#fff";
          ctx.lineWidth = 2;
          ctx.stroke();
        }
      } else if (type === "resource") {
      	
        ctx.fillStyle = resources_colors[obj.type]
        
        ctx.beginPath();
        ctx.rect(-8, -8, 16, 16);
        ctx.fill();
      } else if (type === "building") {

        var img1 = new Image();
        img1.src=`${obj.type}.png`
        ctx.drawImage(img1, -50, -450, 100, 500)
        //ctx.fillStyle = "#e76f51";
        //ctx.beginPath();
        //ctx.moveTo(0, -10);
        //ctx.lineTo(10, 10);
        //ctx.lineTo(-10, 10);
        //ctx.closePath();
        //ctx.fill();
      }
    });
  }

  updateColonist(c) {
    if (c.moving) {
      let diff = (c.targetAngle - c.currentAngle)%(Math.PI*2);
      if(diff>Math.PI){
        diff= 2*Math.PI - diff
      }
      diff = Math.atan2(Math.sin(diff), Math.cos(diff));
      if (Math.abs(diff) > c.moveSpeed/this.baseRadius*100) {
        c.currentAngle += Math.sign(diff) * c.moveSpeed/this.baseRadius*100;
        c.angle = c.currentAngle%(Math.PI*2);
      } else {
        c.currentAngle = c.targetAngle%(Math.PI*2);;
        c.angle = c.currentAngle%(Math.PI*2);;
        c.moving = false;
      }
      return;
    }

    // Mining logic
    if (c.state === "mining" && c.targetResource) {
      if (c.targetResource.stock > 0) {
        let amount = Math.min(c.miningSpeed[c.targetResource.type] ?? 1, c.capacity, c.targetResource.stock);
        c.capacity -= amount
        c.targetResource.stock -= amount;
        var old_amount = c.carrying[c.targetResource.type]??0;
        c.carrying[c.targetResource.type] = old_amount+amount;
        console.log(c.carrying, c.capacity, c.targetResource.stock)
        if(c.capacity<=0){ 
        	c.state = "to_base";
          c.targetAngle = c.base.angle%(Math.PI*2);;
          c.moving = true;
        }
        
        // REMOVE depleted resource
        if (c.targetResource.stock <= 0) {
          const index = this.resources.indexOf(c.targetResource);
          c.targetResource.list_miners.forEach(c2=> {console.log(c2); c2.state="idle"; c2.targetAngle = c2.base.angle%(Math.PI*2);c2.targetResource=null})
          if (index !== -1) this.resources.splice(index, 1);
          c.targetResource = null;
          c.state = "to_base";
          c.targetAngle = c.base.angle%(Math.PI*2);
        }
      }
    } else if (c.state === "to_base" && !c.moving) {
      // drop off
      console.log('Delivered',c.carrying);
      for(let resource_type in c.carrying){
      	var base_resource_quantity = c.base.resources[resource_type]??0
        c.base.resources[resource_type] = base_resource_quantity+ c.carrying[resource_type];
      }
      c.carrying = {};
      c.capacity = 20;
      if(c.targetResource){
      	c.targetAngle = c.targetResource.angle%(Math.PI*2);;
        c.state = "mining";
        c.moving = true;
      }else{
      	c.state="idle"
      }
      
    } 
  }

  handleClick(x, y) {
    const dx = x - this.center.x;
    const dy = y - this.center.y;
    const clickDist = Math.sqrt(dx * dx + dy * dy);
    const angle = Math.atan2(dy, dx)%(Math.PI*2);
    const surfaceR = this.planetRadius(angle);

    if (Math.abs(clickDist - surfaceR) < 500) {
      const pos = this.getSurfacePosition(angle);

      // Move colonist or assign task
      if (this.selectedColonist) {
        var any_close = false;
        for (let r of this.resources) {
          const rPos = this.getSurfacePosition(r.angle);
          if (Math.hypot(rPos.x - x, rPos.y - y) < 50) {
          	any_close = true;
          	if(this.selectedColonist.targetResource){
            	let r2=this.selectedColonist.targetResource;
              r2.list_miners = r2.list_miners.filter(x => x !== this.selectedColonist);
            } 
            if (this.selectedColonist.assignedFactory) {
              this.selectedColonist.assignedFactory.removeWorker();
            }
            this.selectedColonist.state = "mining";
            this.selectedColonist.targetResource = r;
            r.list_miners.push(this.selectedColonist);
            this.selectedColonist.targetAngle = r.angle%(Math.PI*2);;
            this.selectedColonist.moving = true;
            this.selectedColonist = null;
            return true;
          }
        }
        for (let b of this.buildings) {
          const bPos = this.getSurfacePosition(b.angle);
          if (Math.hypot(bPos.x - x, bPos.y - y) < 50 && b.factory) {
            any_close = true;
            if (this.selectedColonist.assignedFactory) {
              this.selectedColonist.assignedFactory.removeWorker();
            }
            this.selectedColonist.assignedFactory = b.factory;
            b.factory.addWorker();
            this.selectedColonist.state = "working";
            this.selectedColonist.targetAngle = b.angle;
            this.selectedColonist.moving = true;
            this.selectedColonist = null;
            return true;
          }
        }
        
        if(this.selectedColonist.targetResource){
            	let r2=this.selectedColonist.targetResource;
              r2.list_miners = r2.list_miners.filter(x => x !== this.selectedColonist);
            }
        if (this.selectedColonist.assignedFactory) {
          this.selectedColonist.assignedFactory.removeWorker();
        } 
        this.selectedColonist.state = "idle"
				this.selectedColonist.targetResource = null;
        this.selectedColonist.targetAngle = angle;
        this.selectedColonist.moving = true;
        this.selectedColonist = null;
        return true;
      }
    }
    // Click colonist
    for (let c of this.colonists) {
      const cPos = this.getSurfacePosition(c.currentAngle);
      if (Math.hypot(cPos.x - x, cPos.y - y) < 50) {
        this.selectedColonist = c;
        return true;
      }
    }

    // Click building
    for (let b of this.buildings) {
      const bPos = this.getSurfacePosition(b.angle);
      //TODO replace this with angular distance
      if (Math.hypot(bPos.x - x, bPos.y - y) < 50) {
        if(b.type == "base"){
          selectedBase = b;
        }
        this.selectedColonist = null;
        if (b.onClick) b.onClick();
        return true;
      }
    }

    return false;
  }
}

function buildHabitation() {
  if (!selectedBase) return;
  const planet = planets.find(p => p.buildings.includes(selectedBase));

  const iron = selectedBase.resources.iron || 0;
  const copper = selectedBase.resources.copper || 0;

  if (iron >= 50 && copper >= 30) {
    selectedBase.resources.iron -= 50;
    selectedBase.resources.copper -= 30;

    selectedBase.number_buldings +=1

    planet.buildings.push({
      type: "hab",
      angle: selectedBase.spawn_angle,
      hp: 1000
    });
    selectedBase.spawn_angle = selectedBase.spawn_angle + selectedBase.number_buldings * (-1)**(selectedBase.number_buldings) *100/planet.baseRadius
  } else {
    alert("Not enough resources to build a habitation module!");
  }
}

// List of unlocked factories
var unlockedFactories = {"farm":Farm};

// Function to build a factory
function buildFactory(factoryClass) {
  if (!selectedBase) return;
  const planet = planets.find(p => p.buildings.includes(selectedBase));

  const factory = new factoryClass(selectedBase);
  const requiredResources = factory.requiredResources;

  let canBuild = true;
  for (let resource in requiredResources) {
    if ((selectedBase.resources[resource] || 0) < requiredResources[resource]) {
      canBuild = false;
      alert(`Not enough ${resource} : ${selectedBase.resources[resource] || 0}/${requiredResources[resource]}`)
      break;
    }
  }

  if (canBuild) {
    for (let resource in requiredResources) {
      selectedBase.resources[resource] -= requiredResources[resource];
    }

    selectedBase.number_buldings +=1
    planet.buildings.push({
      type: factory.type,
      angle: selectedBase.spawn_angle,
      hp: 1000,
      factory: factory
    });
    selectedBase.spawn_angle = selectedBase.spawn_angle + selectedBase.number_buldings * (-1)**(selectedBase.number_buldings) *100/planet.baseRadius
  } else {
    alert("Not enough resources to build this factory!");
  }
}


// ===== ⭐ MODULAR: Create Multiple Planets =====
function generatePlanets(n = 5) {
  const planets = [];
  const maxTries = 500;

  for (let i = 0; i < n; i++) {
    let tries = 0;
    while (tries < maxTries) {
      let baseRadius = 500 + Math.random() * 2000;
      let amplitude = 20 + Math.random() * 20;
      let x = Math.random() * 30000 - 15000;
      let y = Math.random() * 12000 - 6000;

      const newPlanet = new Planet(x, y, baseRadius, amplitude);
      let tooClose = planets.some(p => {
        let dx = p.center.x - newPlanet.center.x;
        let dy = p.center.y - newPlanet.center.y;
        let dist = Math.sqrt(dx * dx + dy * dy);
        return dist < 2 * (p.baseRadius + newPlanet.baseRadius);
      });

      if (!tooClose) {
        planets.push(newPlanet);
        break;
      }
      tries++;
    }
  }
  return planets;
}

var planets = generatePlanets(5);
planets[0].spawnBase(Math.random() * Math.PI * 2);
var base_pos = planets[0].getSurfacePosition(planets[0].buildings[0].angle)
planets[0].buildings[0].resources = {
  food: 100,
  water: 100
}
panX = document.querySelector("body").clientWidth/2 - base_pos.x * zoom;
panY = document.querySelector("body").clientHeight/2 - base_pos.y * zoom


const uiPanel = document.getElementById("uiPanel");
let selectedBase = null;
let selectedBuilding = null;


// ===== Handle Clicks Delegated to Planets =====

var screenToWorld = (sx, sy) => ({
  x: (sx - panX)/zoom,
  y: (sy - panY)/zoom,
});

canvas.addEventListener("click", (e) => {
  const { x, y } = screenToWorld(e.clientX, e.clientY);
  for (let planet of planets) {
    if (planet.handleClick(x, y)) return;
  }
});

function spawnSpecialist(type) {
	console.log(type);
  if (!selectedBase) return;
  
  const planet = planets.find(p => p.buildings.includes(selectedBase));
  const food = selectedBase.resources.food || 0;
  const water = selectedBase.resources.water || 0;
  //5 colonists by habitation module + 10 by base
  const habs = 5 * planet.buildings.filter(b => b.type === "hab").length + 10 * planet.buildings.filter(b => b.type === "base").length;
  const colonists = planet.colonists.filter(c => c.base === selectedBase).length;

  if (food >= 10 && water >= 5 && colonists < habs) {
    selectedBase.resources.food -= 10;
    selectedBase.resources.water -= 5;

    const colonist = planet.createColonist(selectedBase.spawn_angle);
    if (type === "miner") {
      colonist.miningSpeed = { iron: 2, copper: 2 };
    } else if (type === "soldier") {
      colonist.miningSpeed = {};
      colonist.hp = 120;
      colonist.attack = 100;
      colonist.color = "#ff0000";
    }
    planet.colonists.push(colonist);
  } else {
    alert("Insufficient food, water, or housing space!");
  }

}


// ===== Animation Loop =====
function updateUIPanel() {
  const currentColonist = planets.find(p => p.selectedColonist)?.selectedColonist;

  if (currentColonist && lastUIState.ref !== currentColonist) {
    // Switch to colonist UI
    lastUIState = { type: "colonist", ref: currentColonist };
    selectedBase = null;
    selectedBuilding = null;

    uiPanel.style.display = "block";
    uiPanel.innerHTML = `
      <strong>Colonist</strong><br>
      State: <span id="colonistState">${currentColonist.state}</span><br>
      Carrying:<br><ul id="colonistCarrying"></ul>
    `;
  } else if (selectedBase && lastUIState.ref !== selectedBase) {
    // Switch to base UI
    lastUIState = { type: "base", ref: selectedBase };
    planets.forEach(p => p.selectedColonist = null); // clear selection
    let planet = planets.find(p => p.buildings.includes(selectedBase));

    uiPanel.style.display = "block";
    uiPanel.innerHTML = `
      <strong>Base</strong><br>
      Resources:<br><ul id="baseResources"></ul>
      Colonists: ${planet.colonists.length}/${5 * planet.buildings.filter(b => b.type === "hab").length + 10 * planet.buildings.filter(b => b.type === "base").length}<br>
      Create colonist :
      <button id="spawnSpecialist_miner">Create Miner</button>
      <button id="spawnSpecialist_soldier">Create Soldier</button> (10 food, 5 water)<br>
      <button onclick="buildHabitation()">Build Habitation Module</button> (50 iron, 30 copper)<br>
      <button onclick="buildFactory(Farm)">Build Farm (50 silicon)</button>
    `;

    document.getElementById("spawnSpecialist_miner").onclick = () => spawnSpecialist('miner');
    document.getElementById("spawnSpecialist_soldier").onclick = () => spawnSpecialist('soldier');
  }else if (selectedBuilding && lastUIState.ref !== selectedBuilding) {
    // Switch to base UI
    lastUIState = { type: selectedBuilding.type, ref: selectedBuilding };
    planets.forEach(p => p.selectedColonist = null); // clear selection
    uiPanel.style.display = "block";
    uiPanel.innerHTML = `
      <strong>${selectedBuilding.type}</strong><br>
    `;
    if(selectedBuilding.factory){
      uiPanel.innerHTML+=`Number of workers: ${selectedBuilding.factory.workers}<br>`
    }
  } else if (!currentColonist && !selectedBase && !selectedBuilding) {
    // Nothing selected
    if (lastUIState.type !== null) {
      uiPanel.style.display = "none";
      uiPanel.innerHTML = "";
      lastUIState = { type: null, ref: null };
    }
  }

  // If panel is showing, update dynamic parts
  if (lastUIState.type === "colonist") {
    const c = lastUIState.ref;
    document.getElementById("colonistState").textContent = c.state;
    const ul = document.getElementById("colonistCarrying");
    ul.innerHTML = "";
    for (let type in c.carrying) {
      ul.innerHTML += `<li>${type}: ${c.carrying[type]}</li>`;
    }
  } else if (lastUIState.type === "base") {
    const b = lastUIState.ref;
    const ul = document.getElementById("baseResources");
    ul.innerHTML = "";
    for (let type in b.resources) {
      ul.innerHTML += `<li>${type}: ${b.resources[type]}</li>`;
    }
  }
}




function update() {
  ctx.setTransform(1, 0, 0, 1, 0, 0); // reset any transform
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Apply global camera transform
  ctx.setTransform(zoom, 0, 0, zoom, panX, panY);

  for (let planet of planets) {
    planet.draw();
    for (let building of planet.buildings) {
      if (building.factory) {
        building.factory.process(building.factory.base.resources);
      }
    }
  }
  updateUIPanel();
  requestAnimationFrame(update);
}
update();
</script>
</body>
</html>
